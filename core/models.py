import logging
import re
from curses import panel

from django import forms
from django.conf import settings
from django.contrib.auth.models import Group
from django.core.exceptions import ObjectDoesNotExist, ValidationError
from django.core.mail import EmailMultiAlternatives, send_mail
from django.core.paginator import Paginator
from django.db import models
from django.db.models import Max
from django.http import Http404, HttpResponseNotFound
from django.template.loader import render_to_string
from django.utils.html import strip_tags
from django.utils.text import slugify
from django.utils.translation import gettext_lazy as _
from django.utils.translation import pgettext_lazy
from modelcluster.contrib.taggit import ClusterTaggableManager
from modelcluster.fields import ParentalKey, ParentalManyToManyField
from modelcluster.models import ClusterableModel
from mptt.models import MPTTModel, TreeForeignKey
from taggit.models import ItemBase, TagBase, TaggedItemBase
from wagtail import blocks
from wagtail.admin.panels import FieldPanel, FieldRowPanel, InlinePanel, MultiFieldPanel
from wagtail.contrib.forms.forms import FormBuilder
from wagtail.contrib.forms.models import (
    FORM_FIELD_CHOICES,
    AbstractEmailForm,
    AbstractFormField,
)
from wagtail.embeds.blocks import EmbedBlock
from wagtail.fields import RichTextField, StreamField
from wagtail.images.blocks import ImageChooserBlock
from wagtail.models import Orderable, Page, Site
from wagtail.search import index
from wagtail.snippets.models import register_snippet
from wagtailmodelchooser import Chooser, register_model_chooser
from wagtailmodelchooser.blocks import ModelChooserBlock

from core.blocks import TentronTableBlock, TentronTypedTableBlock
from organization.models import (
    BaseModel,
    BasePage,
    ExtendedSite,
    Organization,
    SiteSettings,
)

from . import blocks as tentron_blocks

logger = logging.getLogger("tentron")
# About
class AboutPage(BasePage):
    subpage_types = ["grapejs.CustomPage"]
    max_count_per_site = 1
    template = "about.html"
    content = StreamField(
        [
            ("rich_text", blocks.RichTextBlock()),
            ("blockquote", tentron_blocks.BlockQuoteBlock()),
            ("image_block", tentron_blocks.ImageBlock()),
            ("image_content_block", tentron_blocks.ImageContentBlock()),
            ("testimonials", tentron_blocks.TestimonialBlock()),
            ("video", EmbedBlock(max_width=800, max_height=400)),
            ("audio", tentron_blocks.AudioBlock()),
            ("carousel", tentron_blocks.CarouselBlock()),
        ],
        null=True,
        blank=True,
        use_json_field=True,
    )

    content_panels = BasePage.content_panels + [
        FieldPanel("content"),
    ]

    def get_context(self, request, *args, **kwargs):
        context = super().get_context(request, *args, **kwargs)
        site = context["tentron_current_site"]
        return context


# Blog
class BlogCategory(MPTTModel, BaseModel):
    name = models.CharField(max_length=255)
    slug = models.SlugField(
        verbose_name=_("slug"),
        allow_unicode=True,
        max_length=255,
        help_text=_(
            "The name of the page as it will appear in URLs e.g http://domain.com/blog/[my-slug]/"
        ),
    )
    icon = models.ForeignKey(
        "wagtailimages.Image",
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name="+",
    )
    description = models.TextField(blank=True)

    parent = TreeForeignKey(
        "self",
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        related_name="children",
    )

    panels = [
        FieldPanel("name"),
        FieldPanel("slug"),
        FieldPanel("description"),
        FieldPanel("icon"),
        FieldPanel("site", permission="is_superuser"),
        FieldPanel("parent"),
    ]

    class Meta:
        verbose_name_plural = "blog categories"

    class MPTTMeta:
        order_insertion_by = ["name"]

    def __str__(self):
        return self.name

    def _slug_is_available(self, slug, site):
        return not ProductType.objects.filter(slug=slug, site=site).exists()

    def _get_autogenerated_slug(self, base_slug, site):
        candidate_slug = base_slug
        suffix = 1
        while not self._slug_is_available(candidate_slug, site):
            # try with incrementing suffix until we find a slug which is available
            suffix += 1
            candidate_slug = "%s-%d" % (base_slug, suffix)

        return candidate_slug

    # overwrite save method to generate unique slug for this site category
    def save(self, *args, **kwargs):
        # check if slug is exist, change it to unique slug
        if self.slug:
            if not self._slug_is_available(self.slug, self.site):
                self.slug = self._get_autogenerated_slug(self.slug, self.site)
        if not self.slug:
            allow_unicode = getattr(settings, "WAGTAIL_ALLOW_UNICODE_SLUGS", True)
            base_slug = slugify(self.name, allow_unicode=allow_unicode)
            if base_slug:
                self.slug = self._get_autogenerated_slug(base_slug, self.site)

        super().save(*args, **kwargs)

    def get_absolute_url(self):
        return f"/blog/{self.slug}/"


class BlogTag(TagBase):
    name = models.CharField(
        verbose_name=pgettext_lazy("A tag name", "name"), max_length=100
    )
    slug = models.SlugField(
        verbose_name=pgettext_lazy("A tag slug", "slug"),
        max_length=100,
        allow_unicode=True,
    )

    site = models.ForeignKey(Site, on_delete=models.SET_NULL, null=True)

    class Meta:
        unique_together = ("name", "slug", "site")
        verbose_name = _("Blog Tag")
        verbose_name_plural = _("Blog Tags")


class TaggedBlog(ItemBase):
    tag = models.ForeignKey(
        BlogTag, related_name="tagged_blogs", on_delete=models.CASCADE
    )
    content_object = ParentalKey(
        to="core.BlogDetailPage", on_delete=models.CASCADE, related_name="tagged_items"
    )


class BlogDetailPageBlogCategory(BaseModel):
    page = ParentalKey(
        "BlogDetailPage", related_name="blog_categories", on_delete=models.CASCADE
    )
    category = models.ForeignKey(
        BlogCategory, related_name="blog_detail_pages", on_delete=models.CASCADE
    )

    panels = [
        FieldPanel("category"),
    ]

    class Meta:
        verbose_name = "Blog Category"
        verbose_name_plural = "Blog Categories"

    def __str__(self):
        return self.category.name


class BlogDetailPage(BasePage):
    BLOG_TYPE_CHOICES = (
        ("standard", "Standard"),
        ("audio", "Audio"),
        ("video", "Video"),
        ("gallery", "Gallery"),
        ("carousel", "Carousel"),
        ("quote", "Quote"),
    )
    template = "blog-details.html"
    parent_page_types = ["core.BlogListPage"]
    subpage_types = []
    tags = ClusterTaggableManager(through="core.TaggedBlog", blank=True)
    content = StreamField(
        [
            ("rich_text", blocks.RichTextBlock()),
            ("blockquote", tentron_blocks.BlockQuoteBlock()),
            ("image_block", tentron_blocks.ImageBlock()),
            ("image_content_block", tentron_blocks.ImageContentBlock()),
            ("testimonials", tentron_blocks.TestimonialBlock()),
            ("video", EmbedBlock(max_width=800, max_height=400)),
            ("audio", tentron_blocks.AudioBlock()),
            ("carousel", tentron_blocks.CarouselBlock()),
        ],
        null=True,
        blank=True,
        use_json_field=True,
    )
    excerpt = models.CharField(max_length=200, blank=True, editable=False)

    cover_image = models.ForeignKey(
        "wagtailimages.Image",
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name="+",
    )
    blog_type = models.CharField(
        max_length=50,
        choices=BLOG_TYPE_CHOICES,
        default="standard",
        blank=True,
    )

    content_panels = BasePage.content_panels + [
        FieldPanel("blog_type"),
        FieldPanel("cover_image"),
        FieldPanel("tags"),
        InlinePanel("blog_categories", label="Blog Categories"),
        FieldPanel("content"),
    ]

    def get_context(self, request, *args, **kwargs):
        context = super().get_context(request, *args, **kwargs)
        site = context["tentron_current_site"]
        pre_post = (
            BlogDetailPage.objects.live()
            .filter(site=site)
            .filter(live=True)
            .filter(first_published_at__lt=self.first_published_at)
            .order_by("-first_published_at")
            .first()
        )
        next_post = (
            BlogDetailPage.objects.live()
            .filter(site=site)
            .filter(live=True)
            .filter(first_published_at__gt=self.first_published_at)
            .order_by("first_published_at")
            .first()
        )
        context["pre_post"] = pre_post
        context["next_post"] = next_post
        context["blog_list_page"] = (
            BlogListPage.objects.live().filter(site=site).first()
        )
        context["categories"] = BlogCategory.objects.filter(site=site).all()
        context["recent_posts"] = (
            BlogDetailPage.objects.live()
            .filter(site=site)
            .filter(live=True)
            .order_by("-first_published_at")[:3]
        )
        # Top 10 tags
        context["top_tags"] = (
            BlogTag.objects.filter(site=site)
            .annotate(num_times=models.Count("tagged_blogs"))
            .order_by("-num_times")[:10]
        )

        return context

    def get_content_excerpt(self, length=200):
        # Initialize an empty string to store the text
        text = ""

        # Iterate over the blocks in the content field
        for block in self.content:
            # Check the type of the block
            if block.block_type == "rich_text":
                # If the block is a RichTextBlock, append its text to the string
                text += strip_tags(block.value.source)
            elif block.block_type == "blockquote":
                # If the block is a BlockQuoteBlock, append its text to the string
                # unpack the block value to get the quote
                text += strip_tags(block.value["quote"])
            # Add more elif clauses here for other block types that contain text

        # Return the first `length` characters of the text
        return text[:length]

    def get_cover(self):
        if self.cover_image:
            return self.cover_image
        for block in self.content:
            if block.block_type == "image_content_block":
                return block.value["image"]
            elif block.block_type == "image_block":
                return block.value["image"]
        return None

    def get_audio_url(self):
        if self.blog_type == "audio":
            for block in self.content:
                if block.block_type == "audio":
                    return block.value["file"].url
        return None

    def get_video_url(self):
        if self.blog_type == "video":
            for block in self.content:
                if block.block_type == "video":
                    return block.value.url
        return None

    def save(self, *args, **kwargs):
        self.excerpt = self.get_content_excerpt()
        super().save(*args, **kwargs)
        # update the site field for each tag.
        # update the site field for each tag.
        for tag in self.tags.all():
            # Check if the tag is already associated with the current site
            if tag.site is None:
                tag.site = self.site
                tag.save()

    def all_tags(self):
        return self.tags.filter(site=self.site)


class BlogListPage(BasePage):
    max_count_per_site = 1
    template = "blog.html"
    subpage_types = ["core.BlogDetailPage"]
    content = StreamField(
        [
            ("rich_text", blocks.RichTextBlock()),
            ("image_block", tentron_blocks.ImageBlock()),
            ("image_content_block", tentron_blocks.ImageContentBlock()),
            ("testimonials", tentron_blocks.TestimonialBlock()),
            ("video", EmbedBlock(max_width=800, max_height=400)),
            ("audio", tentron_blocks.AudioBlock()),
            ("carousel", tentron_blocks.CarouselBlock()),
        ],
        null=True,
        blank=True,
        use_json_field=True,
    )

    content_panels = BasePage.content_panels + [
        FieldPanel("content", classname="full"),
    ]

    def get_context(self, request, *args, **kwargs):
        context = super().get_context(request, *args, **kwargs)
        site = context["tentron_current_site"]
        # Get filter parameters from request
        category = request.GET.get("category")
        tag = request.GET.get("tag")

        # Get all blog posts for the current site
        blog_posts = BlogDetailPage.objects.live().filter(site=site)

        # Filter blog posts by category if the category parameter is provided
        if category:
            blog_posts = blog_posts.filter(blog_categories__category__slug=category)

        # Filter blog posts by tag if the tag parameter is provided
        if tag:
            blog_posts = blog_posts.filter(tags__slug=tag)
        paginator = Paginator(blog_posts, 2)

        page_number = request.GET.get("page")
        page_obj = paginator.get_page(page_number)
        context["page_obj"] = page_obj
        context["categories"] = BlogCategory.objects.filter(site=site).all()
        context["recent_posts"] = (
            BlogDetailPage.objects.live()
            .filter(site=site)
            .filter(live=True)
            .order_by("-first_published_at")[:3]
        )
        # Top 10 tags
        context["top_tags"] = (
            BlogTag.objects.filter(site=site)
            .annotate(num_times=models.Count("tagged_blogs"))
            .order_by("-num_times")[:10]
        )
        context["blog_list_page"] = (
            BlogListPage.objects.live().filter(site=site).first()
        )

        return context


# Contact
class FormField(AbstractFormField):
    page = ParentalKey(
        "core.ContactPage", on_delete=models.CASCADE, related_name="form_fields"
    )


class ContactPage(BasePage, AbstractEmailForm):
    subpage_types = ["grapejs.CustomPage"]
    max_count_per_site = 1
    template = "contact.html"
    landing_page_template = "contact-landing.html"
    sub_title = RichTextField(blank=True)
    intro = RichTextField(blank=True)
    thank_you_text = RichTextField(blank=True)

    content = StreamField(
        [
            ("rich_text", blocks.RichTextBlock()),
            ("image_block", tentron_blocks.ImageBlock()),
            ("image_content_block", tentron_blocks.ImageContentBlock()),
            ("testimonials", tentron_blocks.TestimonialBlock()),
            ("video", EmbedBlock(max_width=800, max_height=400)),
            ("audio", tentron_blocks.AudioBlock()),
            ("carousel", tentron_blocks.CarouselBlock()),
        ],
        null=True,
        blank=True,
        use_json_field=True,
    )

    content_panels = AbstractEmailForm.content_panels + [
        FieldPanel("breadcrumb_background"),
        FieldPanel("sub_title"),
        FieldPanel("intro"),
        FieldPanel("thank_you_text"),
        FieldPanel("content", classname="full"),
        InlinePanel("form_fields", label="Form fields"),
        # MultiFieldPanel(
        #     [
        #         FieldRowPanel(
        #             [
        #                 FieldPanel("from_address", classname="col6"),
        #                 FieldPanel("to_address", classname="col6"),
        #             ]
        #         ),
        #         FieldPanel("subject"),
        #     ],
        #     "Email",
        # ),
    ]

    def get_context(self, request, *args, **kwargs):
        context = super().get_context(request, *args, **kwargs)
        site = context["tentron_current_site"]
        return context


# Faq
class FaqCategory(BaseModel):

    name = models.CharField(max_length=255)
    slug = models.SlugField(
        verbose_name=_("slug"),
        allow_unicode=True,
        max_length=255,
        help_text=_(
            "The name of the page as it will appear in URLs e.g http://domain.com/blog/[my-slug]/"
        ),
    )
    published = models.BooleanField(
        default=True, help_text=_("Check to publish in FAQ Page")
    )

    def __str__(self):
        return self.name

    panels = [
        FieldPanel("name"),
        FieldPanel("slug", permission="is_superuser"),
        FieldPanel("site", permission="is_superuser"),
    ]
    # check if the category is used by any faq item
    def is_used(self):
        return FaqItem.objects.filter(category=self).exists()

    def _slug_is_available(self, slug, site):
        return not FaqCategory.objects.filter(slug=slug, site=site).exists()

    def _get_autogenerated_slug(self, base_slug, site):
        candidate_slug = base_slug
        suffix = 1
        while not self._slug_is_available(candidate_slug, site):
            # try with incrementing suffix until we find a slug which is available
            suffix += 1
            candidate_slug = "%s-%d" % (base_slug, suffix)

        return candidate_slug

    def save(self, *args, **kwargs):
        if self.slug:
            if not self._slug_is_available(self.slug, self.site):
                self.slug = self._get_autogenerated_slug(self.slug, self.site)
        if not self.slug:
            allow_unicode = getattr(settings, "WAGTAIL_ALLOW_UNICODE_SLUGS", True)
            base_slug = slugify(self.name, allow_unicode=allow_unicode)
            if base_slug:
                self.slug = self._get_autogenerated_slug(base_slug, self.site)

        super().save(*args, **kwargs)

    class Meta:
        verbose_name = "Faq category"
        verbose_name_plural = "Faq categories"


class FaqCategoryFaqItem(BaseModel):
    faq_item = ParentalKey(
        "core.FaqItem", on_delete=models.CASCADE, related_name="faq_categories"
    )
    faq_category = models.ForeignKey(
        FaqCategory, on_delete=models.CASCADE, related_name="faq_items"
    )

    panels = [
        FieldPanel("faq_category"),
    ]

    # class Meta:
    #     unique_together = ("faq_item", "faq_category")


class FaqItem(ClusterableModel, BaseModel):
    question = models.CharField(max_length=255)
    answer = RichTextField()
    published = models.BooleanField(default=True)

    panels = [
        FieldPanel("question"),
        FieldPanel("answer"),
        InlinePanel("faq_categories", label="Faq categories"),
        FieldPanel("published"),
    ]

    def __str__(self):
        return self.question

    def get_categories(self):
        # only category string

        return ", ".join(
            [category.faq_category.name for category in self.faq_categories.all()]
        )

    get_categories.short_description = "Categories"


class FaqPageFaqCategory(BaseModel):
    page = ParentalKey(
        "core.FaqPage", on_delete=models.CASCADE, related_name="faq_categories"
    )
    faq_category = models.ForeignKey(
        "core.FaqCategory", on_delete=models.CASCADE, related_name="faq_pages"
    )

    panels = [
        FieldPanel("faq_category"),
    ]

    class Meta:
        unique_together = ("page", "faq_category")


class FaqPage(BasePage):
    max_count_per_site = 1
    subpage_types = []
    template = "faq.html"
    content = StreamField(
        [
            ("rich_text", blocks.RichTextBlock()),
            ("image_block", tentron_blocks.ImageBlock()),
            ("image_content_block", tentron_blocks.ImageContentBlock()),
            ("testimonials", tentron_blocks.TestimonialBlock()),
            ("video", EmbedBlock(max_width=800, max_height=400)),
            ("audio", tentron_blocks.AudioBlock()),
            ("carousel", tentron_blocks.CarouselBlock()),
        ],
        null=True,
        blank=True,
        use_json_field=True,
    )
    category_tab_mode = models.BooleanField(
        default=True, help_text=_("Check to show categories as tabs")
    )

    content_panels = BasePage.content_panels + [
        FieldPanel("category_tab_mode"),
        FieldPanel("content", classname="full"),
        InlinePanel("faq_categories", label="Faq categories"),
    ]

    def get_context(self, request, *args, **kwargs):
        context = super().get_context(request, *args, **kwargs)
        site = context["tentron_current_site"]
        # filter empty categories

        faq_categories = FaqCategory.objects.filter(site=site)
        context["faq_categories"] = faq_categories
        faq_items = FaqItem.objects.filter(published=True, site=site)
        print(faq_items)
        context["faq_items"] = faq_items
        total_items = faq_items.count()
        half_items = total_items // 2
        context["faq_items_first_half"] = faq_items[:half_items]
        context["faq_items_second_half"] = faq_items[half_items:]
        context["half_items"] = half_items

        faq_items_dict = {}
        for category in faq_categories:
            c_faq_items = FaqItem.objects.filter(
                published=True, site=site, faq_categories__faq_category=category
            )
            faq_items_dict[category.id] = c_faq_items
        context["faq_items_dict"] = faq_items_dict

        return context


# Project
class ProjectDetailPage(BasePage):
    template = "project-detail.html"
    parent_page_types = ["core.ProjectListPage"]
    content = StreamField(
        [
            ("rich_text", blocks.RichTextBlock()),
            ("image_block", tentron_blocks.ImageBlock()),
            ("image_content_block", tentron_blocks.ImageContentBlock()),
            ("testimonials", tentron_blocks.TestimonialBlock()),
            ("video", EmbedBlock(max_width=800, max_height=400)),
            ("audio", tentron_blocks.AudioBlock()),
            ("carousel", tentron_blocks.CarouselBlock()),
        ],
        null=True,
        blank=True,
        use_json_field=True,
    )

    content_panels = BasePage.content_panels + [
        FieldPanel("content", classname="full"),
    ]

    def get_context(self, request, *args, **kwargs):
        context = super().get_context(request, *args, **kwargs)
        site = context["tentron_current_site"]
        return context


class ProjectListPage(BasePage):
    max_count_per_site = 1
    template = "projects.html"
    subpage_types = ["core.ProjectDetailPage"]
    content = StreamField(
        [
            ("rich_text", blocks.RichTextBlock()),
            ("image_block", tentron_blocks.ImageBlock()),
            ("image_content_block", tentron_blocks.ImageContentBlock()),
            ("testimonials", tentron_blocks.TestimonialBlock()),
            ("video", EmbedBlock(max_width=800, max_height=400)),
            ("audio", tentron_blocks.AudioBlock()),
            ("carousel", tentron_blocks.CarouselBlock()),
        ],
        null=True,
        blank=True,
        use_json_field=True,
    )

    content_panels = BasePage.content_panels + [
        FieldPanel("content", classname="full"),
    ]

    def get_context(self, request, *args, **kwargs):
        context = super().get_context(request, *args, **kwargs)
        site = context["tentron_current_site"]
        return context


# Service
class ServiceDetailPage(BasePage):
    template = "services-detail.html"
    parent_page_types = ["core.ServiceListPage"]
    subpage_types = []
    content = StreamField(
        [
            ("rich_text", blocks.RichTextBlock()),
            ("blockquote", tentron_blocks.BlockQuoteBlock()),
            ("image_block", tentron_blocks.ImageBlock()),
            ("image_content_block", tentron_blocks.ImageContentBlock()),
            ("testimonials", tentron_blocks.TestimonialBlock()),
            ("video", EmbedBlock(max_width=800, max_height=400)),
            ("audio", tentron_blocks.AudioBlock()),
            ("carousel", tentron_blocks.CarouselBlock()),
        ],
        null=True,
        blank=True,
        use_json_field=True,
    )

    content_panels = BasePage.content_panels + [
        FieldPanel("content", classname="full"),
    ]

    def get_context(self, request, *args, **kwargs):
        context = super().get_context(request, *args, **kwargs)
        site = context["tentron_current_site"]
        context["service_detail_pages"] = (
            ServiceDetailPage.objects.filter(site=site).live().order_by("-title")
        )
        return context


class ServiceListPageServiceDetailPage(Orderable):
    page = ParentalKey(
        "core.ServiceListPage",
        on_delete=models.CASCADE,
        related_name="service_detail_pages",
    )
    service_detail_page = models.ForeignKey(
        "core.ServiceDetailPage",
        on_delete=models.CASCADE,
        related_name="service_list_pages",
    )

    panels = [
        FieldPanel("service_detail_page"),
    ]

    @property
    def search_description(self):
        return self.service_detail_page.search_description

    @property
    def url(self):
        return self.service_detail_page.url

    @property
    def beautify_title(self):
        return self.service_detail_page.beautify_title


class ServiceListPage(BasePage):
    max_count_per_site = 1
    template = "services.html"
    subpage_types = ["core.ServiceDetailPage"]
    heading = models.CharField(max_length=50, null=True, blank=True)
    subheading = models.CharField(max_length=50, null=True, blank=True)
    content = StreamField(
        [
            ("rich_text", blocks.RichTextBlock()),
            ("blockquote", tentron_blocks.BlockQuoteBlock()),
            ("image_block", tentron_blocks.ImageBlock()),
            ("image_content_block", tentron_blocks.ImageContentBlock()),
            ("testimonials", tentron_blocks.TestimonialBlock()),
            ("video", EmbedBlock(max_width=800, max_height=400)),
            ("audio", tentron_blocks.AudioBlock()),
            ("carousel", tentron_blocks.CarouselBlock()),
        ],
        null=True,
        blank=True,
        use_json_field=True,
    )

    content_panels = BasePage.content_panels + [
        InlinePanel(
            "service_detail_pages",
            label="Service Detail Pages",
            help_text=_(
                "Select Service Detail Pages, if empty, all Service Detail Pages will be shown"
            ),
        ),
        FieldPanel("content", classname="full"),
    ]

    def get_context(self, request, *args, **kwargs):
        context = super().get_context(request, *args, **kwargs)
        site = context["tentron_current_site"]
        # Check if service_detail_pages exist
        if self.service_detail_pages.exists():
            # If service_detail_pages exist, pass them to the context
            context["service_pages"] = self.service_detail_pages.all()
        else:
            # If service_detail_pages do not exist, get all ServiceDetailPage children of ServiceListPage and pass them to the context
            context["service_pages"] = ServiceDetailPage.objects.live().descendant_of(
                self
            )
        return context


# Team
class TeamDetailPage(BasePage):
    template = "team-details.html"
    parent_page_types = ["core.TeamListPage"]
    content = RichTextField()

    name = models.CharField(max_length=255, blank=True, null=True)
    designation = models.CharField(max_length=255, null=True, blank=True)
    image = models.ForeignKey(
        "wagtailimages.Image",
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name="+",
    )
    email = models.EmailField(null=True, blank=True)
    phone = models.CharField(max_length=255, null=True, blank=True)
    address = models.CharField(max_length=255, null=True, blank=True)

    social = StreamField(
        [("socials", tentron_blocks.SocialBlock())],
        null=True,
        blank=True,
        use_json_field=True,
    )

    content_panels = BasePage.content_panels + [
        FieldPanel("name"),
        FieldPanel("designation"),
        FieldPanel("image"),
        FieldPanel("email"),
        FieldPanel("phone"),
        FieldPanel("address"),
        FieldPanel("social"),
        FieldPanel("content", classname="full"),
    ]

    def get_context(self, request, *args, **kwargs):
        context = super().get_context(request, *args, **kwargs)
        site = context["tentron_current_site"]
        return context


class TeamListPage(BasePage):
    max_count_per_site = 1
    template = "team.html"
    subpage_types = ["core.TeamDetailPage"]
    content = StreamField(
        [
            ("rich_text", blocks.RichTextBlock()),
            ("image_block", tentron_blocks.ImageBlock()),
            ("image_content_block", tentron_blocks.ImageContentBlock()),
            ("testimonials", tentron_blocks.TestimonialBlock()),
            ("video", EmbedBlock(max_width=800, max_height=400)),
            ("audio", tentron_blocks.AudioBlock()),
            ("carousel", tentron_blocks.CarouselBlock()),
        ],
        null=True,
        blank=True,
        use_json_field=True,
    )

    content_panels = BasePage.content_panels + [
        FieldPanel("content", classname="full"),
    ]

    def get_context(self, request, *args, **kwargs):
        context = super().get_context(request, *args, **kwargs)
        site = context["tentron_current_site"]
        team_detail_pages = TeamDetailPage.objects.live().descendant_of(
            self, inclusive=True
        )
        context["team_detail_pages"] = team_detail_pages
        return context


# Product
class ProductTag(TaggedItemBase):
    content_object = ParentalKey(
        "ProductPage", related_name="tagged_items", on_delete=models.CASCADE
    )


class ProductType(MPTTModel, BaseModel):
    name = models.CharField(max_length=255)
    slug = models.SlugField(
        verbose_name=_("slug"),
        allow_unicode=True,
        max_length=255,
        help_text=_(
            "The name of the page as it will appear in URLs e.g http://domain.com/product/[my-slug]/"
        ),
    )
    icon = models.ForeignKey(
        "wagtailimages.Image",
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name="+",
    )

    description = models.TextField(blank=True)
    parent = TreeForeignKey(
        "self", on_delete=models.CASCADE, null=True, blank=True, related_name="children"
    )

    panels = [
        FieldPanel("name"),
        FieldPanel("slug"),
        FieldPanel("description"),
        FieldPanel("icon"),
        FieldPanel("site", permission="is_superuser"),
        FieldPanel("parent"),
    ]

    def __str__(self):
        return self.name

    class Meta:
        verbose_name_plural = "product types"

    class MPTTMeta:
        order_insertion_by = ["name"]

    def _slug_is_available(self, slug, site):
        return not ProductType.objects.filter(slug=slug, site=site).exists()

    def _get_autogenerated_slug(self, base_slug, site):
        candidate_slug = base_slug
        suffix = 1
        while not self._slug_is_available(candidate_slug, site):
            # try with incrementing suffix until we find a slug which is available
            suffix += 1
            candidate_slug = "%s-%d" % (base_slug, suffix)

        return candidate_slug

    # overwrite save method to generate unique slug for this site category
    def save(self, *args, **kwargs):
        # check if slug is exist, change it to unique slug
        if self.slug:
            if not self._slug_is_available(self.slug, self.site):
                self.slug = self._get_autogenerated_slug(self.slug, self.site)
        if not self.slug:
            allow_unicode = getattr(settings, "WAGTAIL_ALLOW_UNICODE_SLUGS", True)
            base_slug = slugify(self.name, allow_unicode=allow_unicode)
            if base_slug:
                self.slug = self._get_autogenerated_slug(base_slug, self.site)

        super().save(*args, **kwargs)


class ProductPageProductType(BaseModel):
    page = ParentalKey(
        "ProductPage", related_name="product_types", on_delete=models.CASCADE
    )
    type = models.ForeignKey(
        ProductType, related_name="product_detail_pages", on_delete=models.CASCADE
    )

    panels = [
        FieldPanel("type"),
    ]

    def __str__(self):
        return self.type.name

    class Meta:
        unique_together = ("page", "type")

    def name(self):
        return self.type.name

    def slug(self):
        return self.type.slug

    def parent(self):
        return self.type.parent

    def icon(self):
        return self.type.icon


class Attribute(BaseModel):
    ATTRIBUTE_TYPES = [
        ("text", "Text"),
        ("select", "Select"),
        ("checkbox", "Checkbox"),
        ("radio", "Radio"),
        ("image", "Image"),
    ]

    name = models.CharField(max_length=255)
    slug = models.SlugField(max_length=255)
    type = models.CharField(max_length=50, choices=ATTRIBUTE_TYPES)
    order = models.PositiveIntegerField(default=0)

    class Meta:
        ordering = ["order"]

    def __str__(self):
        return self.name

    panels = [
        FieldPanel("site", permission="is_superuser"),
        FieldPanel("name"),
        FieldPanel("slug"),
        FieldPanel("type"),
        FieldPanel("order"),
    ]
    # check if the category is used by any faq item
    def is_used(self):
        return Attribute.objects.filter(category=self).exists()

    def _slug_is_available(self, slug, site):
        return not FaqCategory.objects.filter(slug=slug, site=site).exists()

    def _get_autogenerated_slug(self, base_slug, site):
        candidate_slug = base_slug
        suffix = 1
        while not self._slug_is_available(candidate_slug, site):
            # try with incrementing suffix until we find a slug which is available
            suffix += 1
            candidate_slug = "%s-%d" % (base_slug, suffix)

        return candidate_slug

    def save(self, *args, **kwargs):
        # check if slug is exist, change it to unique slug
        if self.slug:
            if not self._slug_is_available(self.slug, self.site):
                self.slug = self._get_autogenerated_slug(self.slug, self.site)
        if not self.slug:
            allow_unicode = getattr(settings, "WAGTAIL_ALLOW_UNICODE_SLUGS", True)
            base_slug = slugify(self.name, allow_unicode=allow_unicode)
            if base_slug:
                self.slug = self._get_autogenerated_slug(base_slug, self.site)

        super().save(*args, **kwargs)


@register_snippet
class AttributeValue(BaseModel, index.Indexed):
    attribute = models.ForeignKey(
        Attribute, related_name="values", on_delete=models.CASCADE
    )
    value = models.CharField(max_length=255)

    # search_fields = [
    #     index.SearchField("value"),
    #     index.FilterField("deleted_at"),
    #     index.FilterField("site_id"),
    # ]

    def __str__(self):
        return self.value

    panels = [
        FieldPanel("site", permission="is_superuser"),
        FieldPanel("attribute"),
        FieldPanel("value"),
    ]


class SingleProductPageAttributeValue(Orderable):
    page = ParentalKey(
        "SingleProductPage", related_name="single_product_page_attribute_values"
    )
    attribute = models.ForeignKey(Attribute, related_name="+", on_delete=models.CASCADE)
    attribute_value = models.CharField(max_length=255)

    panels = [
        FieldPanel("attribute"),
        FieldPanel("attribute_value"),
    ]

    def __str__(self):
        return self.attribute.name


class SingleProductGalleryImage(Orderable):
    page = ParentalKey(
        "SingleProductPage", related_name="single_product_gallery_images"
    )
    image = models.ForeignKey(
        "wagtailimages.Image", related_name="+", on_delete=models.CASCADE
    )
    caption = models.CharField(blank=True, max_length=250)

    panels = [
        FieldPanel("image"),
        FieldPanel("caption"),
    ]

    @property
    def src(self):
        return self.image.file.url


class VariantProductGalleryImage(Orderable):
    page = ParentalKey("ProductVariant", related_name="product_variant_gallery_images")
    image = models.ForeignKey(
        "wagtailimages.Image", related_name="+", on_delete=models.CASCADE
    )
    caption = models.CharField(blank=True, max_length=250)

    panels = [
        FieldPanel("image"),
        FieldPanel("caption"),
    ]

    @property
    def src(self):
        return self.image.file.url


class ProductVariantAttributeOrderable(Orderable):
    page = ParentalKey("ProductVariant", related_name="attributes")
    attribute = models.ForeignKey(
        Attribute, related_name="product_variant_attributes", on_delete=models.CASCADE
    )
    value = models.ForeignKey(
        AttributeValue, related_name="product_variant_values", on_delete=models.CASCADE
    )

    panels = [
        FieldPanel("attribute"),
        FieldPanel("value"),
    ]


class ProductVariant(ClusterableModel, BaseModel):
    product = ParentalKey(
        "VariantProductPage", related_name="variants", on_delete=models.CASCADE
    )

    price = models.DecimalField(max_digits=10, decimal_places=2, blank=True, null=True)
    sales_price = models.DecimalField(
        max_digits=10, decimal_places=2, blank=True, null=True
    )
    stock = models.PositiveIntegerField(default=0, blank=True, null=True)
    sku = models.CharField(max_length=255, blank=True, null=True)

    panels = [
        FieldPanel("price"),
        FieldPanel("sales_price"),
        FieldPanel("stock"),
        FieldPanel("sku"),
        InlinePanel(
            "product_variant_gallery_images",
            max_num=5,
            min_num=1,
            label="Product Gallery Images",
        ),
        InlinePanel("attributes", label="Attributes"),
    ]

    def save(self, *args, **kwargs):
        super().save(*args, **kwargs)
        # self.attributes.set(self.attributes.values_list("id", flat=True))


class ProductPage(BasePage):
    parent_page_types = ["core.ProductListPage"]
    subpage_types = []
    short_description = RichTextField(null=True, blank=True)
    tags = ClusterTaggableManager(through=ProductTag, blank=True)
    content = StreamField(
        [
            ("heading", blocks.CharBlock(classname="full title")),
            ("paragraph", blocks.RichTextBlock()),
            ("image", ImageChooserBlock()),
            (
                "table",
                TentronTableBlock(
                    table_options={
                        "minSpareRows": 0,
                        "startRows": 6,
                        "startCols": 4,
                        "colHeaders": False,
                        "rowHeaders": False,
                        "contextMenu": [
                            "row_above",
                            "row_below",
                            "---------",
                            "col_left",
                            "col_right",
                            "---------",
                            "remove_row",
                            "remove_col",
                            "---------",
                            "undo",
                            "redo",
                            "---------",
                            "copy",
                            "cut" "---------",
                            "alignment",
                        ],
                        "editor": "text",
                        "stretchH": "all",
                        "height": 216,
                        "renderer": "html",
                        "autoColumnSize": True,
                    }
                ),
            ),
            (
                "typed_table",
                TentronTypedTableBlock(
                    [
                        ("text", blocks.CharBlock()),
                        ("numeric", blocks.FloatBlock()),
                        ("rich_text", blocks.RichTextBlock()),
                        ("image", ImageChooserBlock()),
                    ]
                ),
            ),
        ],
        null=True,
        blank=True,
        use_json_field=True,
    )

    def get_categories(self):
        return self.product_types.all()

    def get_context(self, request, *args, **kwargs):
        context = super().get_context(request, *args, **kwargs)
        site = context["tentron_current_site"]
        product_form_page = ProductForm.objects.filter(site=site).first()
        if product_form_page:
            # Create the form and add it to the context
            form = product_form_page.get_form()
            context["form"] = form
            context["product_form_page"] = product_form_page

        return context


class SingleProductPage(ProductPage):
    template = "product-page-single.html"
    price = models.DecimalField(max_digits=10, decimal_places=2, blank=True, null=True)
    sales_price = models.DecimalField(
        max_digits=10, decimal_places=2, blank=True, null=True
    )
    content_panels = ProductPage.content_panels + [
        FieldPanel("price"),
        FieldPanel("sales_price"),
        MultiFieldPanel(
            [
                FieldPanel("tags"),
                InlinePanel("product_types", label="Product types"),
                InlinePanel(
                    "single_product_gallery_images",
                    max_num=5,
                    min_num=1,
                    label="Product Gallery Images",
                ),
                InlinePanel(
                    "single_product_page_attribute_values", label="Product Attributes"
                ),
            ],
            heading="Product settings",
        ),
        FieldPanel("short_description", classname="full"),
        FieldPanel("content"),
    ]

    def main_image(self):
        gallery_item = self.single_product_gallery_images.first()
        if gallery_item:
            return gallery_item.image
        return None

    def gallery_images(self):
        return self.single_product_gallery_images.all()


class VariantProductPage(ProductPage):
    template = "product-page-variant.html"
    content_panels = ProductPage.content_panels + [
        MultiFieldPanel(
            [
                FieldPanel("tags"),
                InlinePanel("product_types", label="Product types"),
            ],
            heading="Product settings",
        ),
        FieldPanel("short_description", classname="full"),
        InlinePanel("variants", label="Variants"),
        FieldPanel("content"),
    ]

    def main_image(self):
        gallery_item = self.variants.first().product_variant_gallery_images.first()
        if gallery_item:
            return gallery_item.image
        return None

    def gallery_images(self):
        return self.variants.first().product_variant_gallery_images.all()


class ProductListPage(BasePage):
    max_count_per_site = 1
    template = "product.html"
    subpage_types = ["core.SingleProductPage", "core.VariantProductPage"]
    content = StreamField(
        [
            ("rich_text", blocks.RichTextBlock()),
            ("image_block", tentron_blocks.ImageBlock()),
            ("image_content_block", tentron_blocks.ImageContentBlock()),
            ("testimonials", tentron_blocks.TestimonialBlock()),
            ("video", EmbedBlock(max_width=800, max_height=400)),
            ("audio", tentron_blocks.AudioBlock()),
            ("carousel", tentron_blocks.CarouselBlock()),
        ],
        null=True,
        blank=True,
        use_json_field=True,
    )

    content_panels = BasePage.content_panels + [
        FieldPanel("content", classname="full"),
    ]

    def get_context(self, request, *args, **kwargs):
        context = super().get_context(request, *args, **kwargs)
        product_items = ProductPage.objects.filter(
            site=context["tentron_current_site"]
        ).specific()
        paginator = Paginator(product_items, 2)

        page_number = request.GET.get("page")
        page_obj = paginator.get_page(page_number)
        context["page_obj"] = page_obj

        return context


class ProductFormField(AbstractFormField):
    CHOICES = FORM_FIELD_CHOICES + (("product_id", "Product ID"),)
    page = ParentalKey(
        "ProductForm", on_delete=models.CASCADE, related_name="form_fields"
    )
    column_width = models.IntegerField(choices=((6, "Half"), (12, "Full")), default=12)

    panels = AbstractFormField.panels + [FieldPanel("column_width")]
    field_type = models.CharField(
        verbose_name="field type",
        max_length=16,
        # use the choices tuple defined above
        choices=CHOICES,
    )

    @classmethod
    def can_create_for_site(cls, user, site):
        if user.is_superuser:
            return True
        # check if user is a member of site or organization
        if not user.organization_memberships.filter(
            organization=site.extendedsite.organization
        ).exists():
            return False

        if cls.max_count_per_site is None:
            return True
        current_page_count = cls.objects.filter(site=site).count()
        return current_page_count < cls.max_count_per_site


class ProductFormBuilder(FormBuilder):
    def create_column_width_field(self, field, options):
        return forms.IntegerField(**options)

    def create_product_id_field(self, field, options):
        return forms.IntegerField(**options)


class ProductForm(BasePage, AbstractEmailForm):
    max_count_per_site = 1
    subpage_types = []
    content_panels = AbstractEmailForm.content_panels + [
        InlinePanel("form_fields", label="Form fields"),
    ]
    template = "product-form.html"
    landing_page_template = "product-form-landing.html"

    form_builder = ProductFormBuilder

    def process_form_submission(self, form):
        # check if form has product_id
        form_submission = super().process_form_submission(form)
        if (
            "product_id" in form.data
            and "page_type" in form.data
            and form.data["page_type"] == "VariantProductPage"
        ):

            product_id = form.cleaned_data["product_id"]
            product = VariantProductPage.objects.get(id=product_id)

            # # save the product to form submission
            # print("form submission", form.cleaned_data)

            form_submission.product = product
            form_submission.save()
        # get site settings contact_email, send email to contact_email
        site_settings = SiteSettings.for_site(self.site)
        try:
            product = ProductPage.objects.get(id=form.cleaned_data["product_id"])
            product_name = product.title
        except:
            product_name = "Product"
        if site_settings.contact_email:
            text_content = render_to_string(
                "core/email_templates/product_form.txt",
                {
                    "form": self.render_email(form),
                    "form_data": form.cleaned_data,
                    "product_name": product_name,
                },
            )
            html_content = render_to_string(
                "core/email_templates/product_form.html",
                {
                    "form": self.render_email(form),
                    "form_data": form.cleaned_data,
                    "product_name": product_name,
                },
            )
            mail = EmailMultiAlternatives(
                f"{settings.EMAIL_SUBJECT_PREFIX} 新询盘通知",
                text_content,
                settings.DEFAULT_FROM_EMAIL,
                [site_settings.contact_email],
            )
            mail.attach_alternative(html_content, "text/html")
            mail.send(fail_silently=False)

        return form_submission

    @classmethod
    def can_create_for_site(cls, user, site):
        if user.is_superuser:
            return True
        # check if user is a member of site or organization
        if not user.organization_memberships.filter(
            organization=site.extendedsite.organization
        ).exists():
            return False

        if cls.max_count_per_site is None:
            return True
        current_page_count = cls.objects.filter(site=site).count()
        return current_page_count < cls.max_count_per_site

    def save(self, *args, **kwargs):
        # check if form has product_id field, if not add it, if yes, do nothing

        super().save(*args, **kwargs)
        # https://github.com/wagtail/django-modelcluster/blob/be42bbe179f92a383b21b52b94d5be47fda46cc4/modelcluster/queryset.py#L470
        max_sort_order_obj = self.form_fields.last()

        if max_sort_order_obj is None:
            max_sort_order = 0
        else:
            max_sort_order = max_sort_order_obj.sort_order

        if not self.form_fields.filter(clean_name="product_id").exists():
            product_form_field = ProductFormField(
                page=self,
                label="Product ID",
                field_type="hidden",
                required=True,
                sort_order=max_sort_order + 1,  # set the sort_order for new field
            )
            product_form_field.save()
            max_sort_order += 1  # update max_sort_order for next field

        if not self.form_fields.filter(clean_name="page_type").exists():
            product_form_field = ProductFormField(
                page=self,
                label="Page Type",
                field_type="hidden",
                required=True,
                sort_order=max_sort_order + 1,  # set the sort_order for new field
            )
            product_form_field.save()
            max_sort_order += 1  # update max_sort_order for next field


# Testimonial
class TestimonialItem(BaseModel):
    name = models.CharField(max_length=255)
    content = RichTextField()
    image = models.ForeignKey(
        "wagtailimages.Image",
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name="+",
    )
    position = models.CharField(max_length=255)
    company = models.CharField(max_length=255)

    panels = [
        FieldPanel("name"),
        FieldPanel("content"),
        FieldPanel("image"),
        FieldPanel("position"),
        FieldPanel("company"),
        FieldPanel("site", permission="is_superuser"),
    ]

    def __str__(self):
        return self.name


# Other
class ThankyouPage(BasePage):
    subpage_types = ["grapejs.CustomPage"]
    max_count_per_site = 1
    template = "thank-you.html"
    content = StreamField(
        [
            ("rich_text", blocks.RichTextBlock()),
            ("image_block", tentron_blocks.ImageBlock()),
            ("image_content_block", tentron_blocks.ImageContentBlock()),
            ("testimonials", tentron_blocks.TestimonialBlock()),
            ("video", EmbedBlock(max_width=800, max_height=400)),
            ("audio", tentron_blocks.AudioBlock()),
            ("carousel", tentron_blocks.CarouselBlock()),
        ],
        null=True,
        blank=True,
        use_json_field=True,
    )

    content_panels = BasePage.content_panels + [
        FieldPanel("content", classname="full"),
    ]


@register_model_chooser
class FaqCategoryChooser(Chooser):
    model = FaqCategory
    model_template = "wagtailmodelchooser/modal.html"
    modal_results_template = "wagtailmodelchooser/results.html"

    def get_queryset(self, request):
        qs = super().get_queryset(request)
        if request.user.is_superuser:
            return qs
        site = Site.find_for_request(request)
        return qs.filter(site=site)


@register_model_chooser
class FaqItemChooser(Chooser):
    model = FaqItem
    model_template = "wagtailmodelchooser/modal.html"
    modal_results_template = "wagtailmodelchooser/results.html"

    def get_queryset(self, request):
        qs = super().get_queryset(request)
        if request.user.is_superuser:
            return qs
        site = Site.find_for_request(request)
        return qs.filter(site=site)


@register_model_chooser
class AttributeChooser(Chooser):
    model = Attribute
    model_template = "wagtailmodelchooser/modal.html"
    modal_results_template = "wagtailmodelchooser/results.html"

    def get_queryset(self, request):
        qs = super().get_queryset(request)
        if request.user.is_superuser:
            return qs
        site = Site.find_for_request(request)
        return qs.filter(site=site)


@register_model_chooser
class AttributeValueChooser(Chooser):
    model = AttributeValue
    model_template = "wagtailmodelchooser/modal.html"
    modal_results_template = "wagtailmodelchooser/results.html"

    def get_queryset(self, request):
        qs = super().get_queryset(request)
        if request.user.is_superuser:
            return qs
        site = Site.find_for_request(request)
        return qs.filter(site=site)


@register_model_chooser
class ProductTypeChooser(Chooser):
    model = ProductType
    model_template = "wagtailmodelchooser/modal.html"
    modal_results_template = "wagtailmodelchooser/results.html"

    def get_queryset(self, request):
        qs = super().get_queryset(request)
        if request.user.is_superuser:
            return qs
        site = Site.find_for_request(request)
        return qs.filter(site=site)


@register_model_chooser
class TestimonialItemeChooser(Chooser):
    model = TestimonialItem
    model_template = "wagtailmodelchooser/modal.html"
    modal_results_template = "wagtailmodelchooser/results.html"

    def get_queryset(self, request):
        qs = super().get_queryset(request)
        if request.user.is_superuser:
            return qs
        site = Site.find_for_request(request)
        return qs.filter(site=site)
